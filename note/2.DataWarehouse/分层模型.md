## 数仓/集市分层
### 1. 操作数据层(ODS)
    数据与业务数据保持一致,可以增加字段来进行数据管理分析(insert_time/from_sys)
    存储的历史数据是只读的,提供查询数据问题使用
#### ODS模型
    -- 全量导入:可用于数据初始化,也可用于每日全量同步
    -- 增量导入:根据业务系统数据的某个字段进行增量(如lastmodify)
### 2. 数据明细层(DWD)
    DWD对ODS层的数据进行清洗,标准化,维度退化(维度具体值可加入主表)(时间、分类、地域)
    满足三范式(原子性、数据唯一(有主键)、数据不冗余) 
#### DWD模型
##### 1.范式建模(Inmon) -- 适用于DWD
       自顶向下的设计方式,从操作系统到数仓再到数据集市,遵从三范式,但是也会存在一些冗余(空间换时间-- 维度退化)
       根据不同主题域划分不同的实体,每个实体都遵从范式
       优点:从关系型数据库的角度出发，结合了业务系统的数据模型，能够比较方便的实现数据仓库的建模 缺点: 下游使用需多关联,计算效率低
       该模型主要用于数仓的dwd层,从关系型数据库的角度出发,更易于维护建设,但是由于dwd都是原子粒度,数据量比较大，完全规范的3范式在数据的交互的时候效率比较低下,所以通常会根据实际情况在事实表上做一些冗余,减少过多的数据交互
##### 2.维度建模(Kimball) -- 适用于DWS/DM
###### 1.自底向上的设计方式,从分析决策的角度出发设计模型
###### 2.主要分为星型模型,雪花模型,星座模型,在日常使用中更多使用星座模型
###### 3.模型中主要有事实表/维度表
     设计过程: 根据业务需求确定共用维度+指标(衍生指标)->去除原子粒度,较少数据量-> 后期维护不可修改数据最小粒度
$\color{red}引发问题1:原子指标/复合指标/衍生指标/派生指标？$   

      原子指标:量化业务属性的不可再分的数据,如交易金额
      复合指标:在原子指标基础上,通过公式运算而得出的指标,如客单价
      衍生指标:原子指标+时间周期+修饰词,如当年企划保费收入
 $\color{red}引发问题2:可加性,半可加性和不可加性？$

      可加性事实是指可以按照与事实表关联的任意维度进行汇总。
      半可加性事实只能按照特定维度汇总，不能对所有维度汇总。例如库存可以按照地点和商品进行汇总，而按时间维度把一年中每个月的库存累加则毫无意义。
      完全不可加性，例如比率型事实。对于不可加性的事实，可分解为可加的组件来实现聚集。
##### 3.Data Vault建模
### 3. 数据汇总层/集市层(DWS/DM)
     维度建模,参考上诉模型

### 4. 常用表设计
#### 1.DWD常用的事实事务表,周期快照事实表,累计快照事实表
##### 事实事务表
      随着业务不断产生的数据,一旦产生数据不会在发生变化(交易流水,操作日志等等)
##### 周期快照事实表
      随着业务周期型的推荐而变化,完成间隔周期内的度量统计(年累计、月累计)      
      使用周期+状态度量的组合(年累计保费)
##### 累计快照事实表
      记录不确定周期的度量统计,完全覆盖一个事实的生命周期(如订单状态事实表)
      通常有多个时间字段,用于记录生命周期中的关键时间节点
      只有一条记录用于不断更新
##### 累计快照事实表的实现方式
      1.使用日期分区: 历史分区数据+当天增量数据(冷数据 left join 有修改的数据 union all 当天增量数据)  -- 对性能影响很大,适用于数据量少的情况
      2.使用日期分区,推测生命最长周期,存储周期内的数据,周期外的冷数据存储到冷分区 -- 存储消耗依然很大
      3.使用日期分区,:以生命周期结束时间为分区(如订单完成时间),每天分区存放当天订单完成的数据,订单未完成的数据存放在9999-12-31分区
#### 2.拉链表
      1. 记录每条数据的生命周期,用于保留数据的所有历史状态
      2. 数据为顺序追加方式,全量非分区表
      3. 实现方式: (ods_order_inc 为当天新增订单或者状态有改变的订单)
         insert overwrite table dw_order_info
         -- 如果当天订单状态有变化,则将历史订单状态的end_date置为start_date
         -- 新增订单直接插入
         select 
         a.order_id,
         a.order_create_date,
         a.order_modify_date,
         a.order_status,
         a.start_date,
         case when b.order_id is not null then 'stat_date' else a.end_date emd end_date
         from dw_order_info a 
         left join ods_order_inc b on a.order_id=b.order_id and b.part_dt='star_date'
         union all 
         select 
         a.order_id,
         a.order_create_date,
         a.order_modify_date,
         a.order_status,
         a.start_date,
         '9999-12-31' end_date
         from ods_order_inc a
         where part_dt='star_date'

         -- 如果要查询某一天订单的状态
         select
         *
         from dw_order_info
         where start_date<='2021-09-01'
         and end_date>='2021-09-01'
       4. 详细案例可参考 http://lxw1234.com/archives/2015/08/473.htm
##### 拉链表的使用场景
      1. 数据量很大,比如订单表,需要记录订单所有状态的时间点,且订单状态变化频率以及比例不大;
      2. 设计方案有如下：
         (1) 每天保留一份全量的数据 -- 节省空间,查询性能高,但是不利于查询历史数据
         (2) 每天分区保留全量数据 -- 有历史所有数据,便于查询历史某个节点,但是空间消耗巨大,当然也可以只保留某个周期内的数据
         (3) 拉链表: 当存量数据超过某个周期时,数据量巨大就会导致查询缓慢 -- 可以拆分成两张,一张用于寸历史所有数据,另一张存近一年或者几个月
      3. 拉链表的回滚方案: https://blog.csdn.net/xiaoyc2012/article/details/100545971